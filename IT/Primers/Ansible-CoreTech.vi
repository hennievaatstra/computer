Ansible [on RH8] core tech
==========================

.installation
	. enable EPEL repo
	# dnf install epel-release

	. install ansible
	# dnf install ansible


.inventory
	: an inventory is listing of servers to communicate with
	. syntax:
[group1]
hostname
ip.address

[multigroup:children]
group1
group2

[multigroup:vars]
ansible_user=ansiman


.modes of operation
	. ad-hoc
	: execute ansible cmd with module
	$ ansible <host> -m ping
	: execute ansible cmd with [shell] command
	$ ansible <host> -a 'hostname'
	: execute ansible cmd with module and options
	$ ansible multi -b -m yum -a "name=ntp state=present"
	: execute on single server
	add option --limit "name/ip"
	: run in background
	$ ansible multi -b -B3600 -P 0 -a "yum -y update"

	. playbook
	: execute ansible-playbook <playbook>


.YAML syntax in playbooks
	- structure is shown through indentation [one or more spaces, NO tabs!]
	- sequence items are denoted by a dash
	- key value pairs within a map are separated by a colon
	- greater than sign tell YAML to "automatically quote the next set of indented lines
as one long string, with each line separated by a space"

	- playbook begins with --- to mark as YAML syntax
	- second line:   hosts: [host/group] to mark hosts to run against
	- become: yes	- run commands through sudo
	- tasks: what follows is a list of tasks to run as part of this play

	- to run tasks before/after main 'tasks:
	  - pre_tasks:
	  - post_tasks:
	- special task to run at the END of a play:
	  - handlers:
	  will only be called if the notifying task made a change on the server and doesn't fail

.running playbooks
	.commandline options:
	- limit hosts/group:	'--limit [group/host]'
	- set remote user:	'--user=[username]'
	- set sudo user:	'--become=[username]' or -b
	- run in check mode:	'--check' or -C
	- use custom inventory:	'--inventory=PATH'
	- show verbose output	'-v'
	- extra variables	'--extra-vars=VARS' in 'key=value' format
	- set concurrencies	'--forks=NUM'

.playbooks beyond the basics
	.handlers
definition:
	handlers:
	- name: restart apache
	  service: name=apache2 state=restarted
call:
	tasks:
	- name: run my incredible app, then restart apache
  	  command: /opt/my-incr-app.sh
  	  notify: restart apache

	.inventory variables
	- in inventory file for a few vars per host/group
	- in host_vars/group_vars dirs [in inventory dir] for more complex vars:
	host_vars/<hostname> or group_vars/<group>:
	---
	foo: bar
	bax: qux

	.registered variables:
	store output of command in variable using 'register'
- command: my-app --status
register: myapp_result
- command: do-something-to-my-app
when: "'ready' in myapp_result.stdout"

	.accessing variables:
	simple vars can be used using syntax like: {{ var }}

	.magic variable:
	=hostvars - containing all the defined host variables (from inventory files and any discovered YAML files inside host_vars directories)

	.facts
	=gathered information about each host when a play is run
	use 'setup' module or 'debug' in playbook

	.Vault
1. You take any YAML file you would normally have in your playbook (e.g. a
variables file, host vars, group vars, role default vars, or even task includes!),
and store it in the vault.
2. Ansible encrypts the vault (‘closes the door’), using a key (a password you set).
3. You store the key (your vault’s password) separately from the playbook in a
location only you control or can access.
4. You use the key to let Ansible decrypt the encrypted vault whenever you run
your playbook.

	.prompts
	=require the user to enter the value for a var
vars_prompt:
  - name: which_name
    prompt: "Which name?"

	.tags
	=allows to run/exclude subsets of tasks
	call with '--tags "<tag>,<tag>" ' on cmdline

	.blocks
	=group related tasks together and apply particular task parameters on the block level
	also allow you to handle errors inside the blocks in a way similar to most programming languages’ exception handling.
